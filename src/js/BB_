//
//BB_lineオブジェクト
//
class BB_line extends BB_base {
    constructor(_bbObj, _text, _length, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(51, 153, 0)';
        }
        this.id = UUID.v1();

        this.type = "line";
        this._text = _text;
        this._length = _length;
        this._color = _color;

        var px_len = this._bbObj.meter_to_pixel(this._length)
        this._pt1pos = {
            x: (-1) * px_len / 2,
            y: 0
        };
        this._pt2pos = {
            x: px_len / 2,
            y: 0
        };

        this.draw();
        this.move(100 + px_len / 2, 100);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }

    //座標の扱いが特殊なので座標関連の関数を一部オーバーライド
    position() {
        var _x = this._ourJc.layer(this.id)._transformdx + (this._pt1pos.x + this._pt2pos.x) / 2,
            _y = this._ourJc.layer(this.id)._transformdy + (this._pt1pos.y + this._pt2pos.y) / 2;
        return {
            x: _x,
            y: _y
        };
    }
    moveTo(_x, _y) {
        var layer = this._ourJc.layer(this.id);
        var _curx = layer._transformdx + (this._pt1pos.x + this._pt2pos.x) / 2,
            _cury = layer._transformdy + (this._pt1pos.y + this._pt2pos.y) / 2;
        layer.translate(_x - _curx, _y - _cury);
        return this;
    }
    draw() {
        var above = 15,
            below = 5,
            x1 = this._pt1pos.x,
            y1 = this._pt1pos.y,
            x2 = this._pt2pos.x,
            y2 = this._pt2pos.y,
            obj = this;
        var centerx = (x1 + x2) / 2,
            centery = (y1 + y2) / 2;

        var line = this._ourJc.line({
                points: [
                    [x1, y1],
                    [x2, y2]
                ],
                color: this._color
            })
            .opacity(1).lineStyle({
                lineWidth: 3
            }).layer(this.id),
            pt1col = this._ourJc.circle(x1, y1, this._bbObj.ptcolsize, this._color, true).layer(this.id),
            pt1 = this._ourJc.circle(x1, y1, this._bbObj.ptsize, "#FFFFFF", true).layer(this.id),
            pt1tra = this._ourJc.circle(x1, y1, this._bbObj.pttrasize, "rgba(0,0,0,0)", true).layer(this.id),
            pt2col = this._ourJc.circle(x2, y2, this._bbObj.ptcolsize, this._color, true).layer(this.id),
            pt2 = this._ourJc.circle(x2, y2, this._bbObj.ptsize, "#FFFFFF", true).layer(this.id),
            pt2tra = this._ourJc.circle(x2, y2, this._bbObj.pttrasize, "rgba(0,0,0,0)", true).layer(this.id),
            linename = this._ourJc.text(this._text, centerx, centery + above)
            .align('center').color('#FFFFFF').font('15px sans-serif').layer(this.id),
            linelen = this._ourJc.text(Math.floor(this._length) + "m", centerx, centery - below)
            .align('center').color('#FFFFFF').font('15px sans-serif').layer(this.id);
        this._ourJc.layer(this.id).draggable();

        var txtheight = linelen.getRect().height; //translateTo時に高さがずれるので補正項
        var callback = () => {
            var pos1 = pt1tra.position(),
                pos2 = pt2tra.position(),
                dx = pos2.x - pos1.x,
                dy = pos2.y - pos1.y,
                centerx = (pos1.x + pos2.x) / 2,
                centery = (pos1.y + pos2.y) / 2,
                newlen = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
            pt1col.translateTo(pos1.x, pos1.y);
            pt2col.translateTo(pos2.x, pos2.y);
            pt1.translateTo(pos1.x, pos1.y);
            pt2.translateTo(pos2.x, pos2.y);
            line.points([
                [pt1._x + pt1._transformdx, pt1._y + pt1._transformdy],
                [pt2._x + pt2._transformdx, pt2._y + pt2._transformdy]
            ]);
            linename.translateTo(centerx, centery + above - txtheight);
            linelen.translateTo(centerx, centery - below - txtheight)
                .string(Math.floor(this._bbObj.pixel_to_meter(newlen)) + "m");
            obj._length = this._bbObj.pixel_to_meter(newlen);
            obj._pt1pos = {
                x: pt1._x + pt1._transformdx,
                y: pt1._y + pt1._transformdy
            };
            obj._pt2pos = {
                x: pt2._x + pt2._transformdx,
                y: pt2._y + pt2._transformdy
            };
        };
        pt1tra.draggable(callback);
        pt1tra.optns.drag.val = false;
        pt2tra.draggable(callback);
        pt2tra.optns.drag.val = false;
        pt1tra.mouseover(() => {
            this._ourJc.layer(obj.id).optns.drag.val = false;
            pt1tra.optns.drag.val = true;
        });
        pt1tra.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true;
            pt1tra.optns.drag.val = false;
        });
        pt2tra.mouseover(() => {
            this._ourJc.layer(obj.id).optns.drag.val = false;
            pt2tra.optns.drag.val = true;
        });
        pt2.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true;
            pt2.optns.drag.val = false;
        });
        return this;
    }

    applyZoom(scale, _x, _y) {
        this._pt1pos.x = this._pt1pos.x * scale;
        this._pt1pos.y = this._pt1pos.y * scale;
        this._pt2pos.x = this._pt2pos.x * scale;
        this._pt2pos.y = this._pt2pos.y * scale;
        this._bbObj.BB_base.prototype.applyZoom.apply(this, arguments);
        return this;
    }
}

//
//BB_pointオブジェクト
//
class BB_point extends BB_base {
    constructor(_bbObj, _text, _size, _color, _align, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(0, 0, 0)';
        }
        if (_align === undefined) {
            _align = 0;
        }
        this.id = UUID.v1();

        this.type = "point";
        this._text = _text;
        this._size = parseInt(_size);
        this._align = _align;
        this._color = _color;
        this.draw();
        this.move(100, 100);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }

    draw() {
        var text;
        this._ourJc.circle(0, 0, this._size, this._color, true).opacity(1).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.pttrasize, "rgba(0,0,0,0)", true).layer(this.id);
        if (this._align == 1) {
            // 左側
            text = this._ourJc.text(this._text, (-1) * (this._size + 5), 0)
                .layer(this.id).color('#FFFFFF').font('15px sans-serif')
                .align('right').baseline('middle');
        } else {
            // 右側
            text = this._ourJc.text(this._text, this._size + 5, 0)
                .layer(this.id).color('#FFFFFF').font('15px sans-serif')
                .align('left').baseline('middle');
        }
        this._ourJc.layer(this.id).draggable();
        return this;
    }
}

//
//BB_scoutオブジェクト
//
class BB_scout extends BB_base {
    constructor(_bbObj, _text, _radius, _length, _duration, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 0, 0)';
        }
        this.id = UUID.v1();

        this.type = "scout";
        this._text = _text;
        this._radius = _radius;
        this._length = _length;
        this._duration = _duration;
        this._color = _color;
        //描画して登録。初期座標は偵察半径分ずらす
        this.draw();
        var px_rad = this._bbObj.meter_to_pixel(this._radius);
        this.move(px_rad, px_rad);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }

    draw() {
        var px_rad = this._bbObj.meter_to_pixel(this._radius),
            px_len = this._bbObj.meter_to_pixel(this._length),
            obj = this;

        var frame = this._ourJc.circle(0, 0, px_rad, this._color, false).layer(this.id).opacity(1),
            scout = this._ourJc.circle(0, 0, px_rad, this._color, true).opacity(0.3).layer(this.id),
            area = this._ourJc.scout(0, 0, px_rad, px_len, this._color, true).opacity(0.2).layer(this.id),
            areaf = this._ourJc.scout(0, 0, px_rad, px_len, this._color, false).opacity(1).layer(this.id),
            mask = this._ourJc.scout_mask(0, 0, px_rad, px_len).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.ptsize, '#FFFFFF', true).layer(this.id);
        this._ourJc.text(this._text, 0, -10)
            .align('center').color('#FFFFFF').font('15px sans-serif').layer(this.id);
        this._ourJc.layer(this.id).draggable();


        //角度変更処理
        mask.mousedown((point) => {
            var canvas = jc.canvas(this._bbObj.id),
                tmpmask = this._ourJc.rect(0, 0, canvas.width(), canvas.height(), 'rgba(0, 0, 0, 0)')
                .layer("tmp_" + this.id),
                layer = this._ourJc.layer(this.id),
                tmpLayer = this._ourJc.layer("tmp_" + this.id);
            tmpLayer.level('top');
            var pos_sct = scout.position();
            var startrad = Math.atan2((point.y - pos_sct.y), (point.x - pos_sct.x)),
                baserad = layer.getAngle();
            tmpmask.mousemove((pos) => {
                var nowrad = Math.atan2((pos.y - pos_sct.y), (pos.x - pos_sct.x));
                var rad = baserad + (nowrad - startrad);
                layer.rotateTo((rad * 180 / Math.PI), 0, 0);
            });
            tmpmask.mouseup((point) => {
                this._ourJc.layer("tmp_" + this.id).del();
            });
        });

        mask.mouseover(() => {
            this._ourJc.layer(this.id).optns.drag.val = false;
        }); // ドラッグ無効
        mask.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true;
        }); // ドラッグ有効

        //偵察機のアニメーション
        mask.dblclick(() => {
            //durationの単位はミリ秒のはずだが誤差がある…？
            scout.translate(px_len, 0,
                obj._duration * 1000,
                undefined, {
                    fn: function() {
                        frame.animate({
                            x: scout._transformdx,
                            y: scout._transformdy
                        });
                    }
                },
                function() {
                    obj.redraw();
                });
            return false;
        });
        return this;
    }
}

//
//BB_sensorオブジェクト
//
class BB_sensor extends BB_base {
    constructor(_bbObj, _text, _radius, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 0, 0)';
        }
        this.id = UUID.v1();

        this.type = "sensor";
        this._text = _text;
        this._radius = _radius;
        this._color = _color;
        //描画して登録。初期座標は偵察半径分ずらす
        this.draw();
        var px_rad = this._bbObj.meter_to_pixel(this._radius);
        this.move(px_rad, px_rad);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }
    draw() {
        var px_rad = this._bbObj.meter_to_pixel(this._radius);
        this._ourJc.circle(0, 0, px_rad, this._color, false).opacity(1).layer(this.id);
        this._ourJc.circle(0, 0, px_rad, this._color, true).opacity(0.5).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.ptsize, this._color, true).layer(this.id).color('#FFFFFF');
        this._ourJc.text(this._text, 0, -10)
            .align('center').layer(this.id).color('#FFFFFF').font('15px sans-serif');
        this._ourJc.layer(this.id).draggable();
        return this;
    }
}

//
//BB_radarオブジェクト
//
class BB_radar extends BB_base {
    constructor(_bbObj, _text, _radius, _angle, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 0, 0)';
        }
        this.id = UUID.v1();

        this.type = "radar";
        this._text = _text;
        this._radius = _radius;
        this._angle = _angle;
        this._color = _color;
        //描画して登録。初期座標は偵察半径分ずらす
        //支援マークはファイル依存させないため手打ち。
        this._image = new Image;
        this._image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAIAAAC0tAIdAAAABnRS' + 'TlMA/wD/AP83WBt9AAAAZUlEQVR42qWRSwrAMAhEK4j3v64LMZQGk5hJsdRVxjw/g+TuVzlopo' + 'loJxYgBERTQabTYinZ6WgM6cgvNHQ8f930o1VVROCcKBj0bveNHuPOEuwNaeCyNzi8f1zHzJi5' + 'evlKfKMbjWF644wwKScAAAAASUVORK5CYII=';
        var obj = this;
        this._image.onload = () => {
            obj.draw();
            var px_rad = this._bbObj.meter_to_pixel(obj._radius);
            obj.move(px_rad, px_rad);
            obj.regist();
            if (typeof(_callback) === "function") {
                _callback.apply(obj);
            }
            delete this._image;
        };
    }
    draw() {
        var px_rad = this._bbObj.meter_to_pixel(this._radius),
            obj = this,
            img_width = this._image.width,
            img_height = this._image.height,
            img_rad = Math.sqrt(Math.pow(this._image.width, 2) + Math.pow(this._image.height, 2)) * 0.5;

        this._ourJc.sector(0, 0, px_rad, this._angle, this._color, false).opacity(1).layer(this.id);
        var area = this._ourJc.sector(0, 0, px_rad, this._angle, this._color, true).opacity(0.5).layer(this.id);
        this._ourJc.circle(0, 0, img_rad, this._color, true).opacity(0.9).layer(this.id);
        this._ourJc.circle(0, 0, img_rad - 2, '#ffffff', true).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.pttrasize, 'rgba(0,0,0,0)', true).layer(this.id);
        this._ourJc.image(this._image, img_width * (-0.5), img_height * (-0.5), img_width, img_height).layer(this.id)
            .rotate(90);
        var text = this._ourJc.text(this._text, 60, 0)
            .align('center').layer(this.id).color('#FFFFFF').font('15px sans-serif');
        this._ourJc.layer(this.id).draggable();

        //移動処理(draggableでは回転できないため、独自定義)
        var mdEvent = (point) => {
            var pos_base = area.position(),
                canvas = jc.canvas(this._bbObj.id),
                radius = Math.sqrt(Math.pow((point.x - pos_base.x), 2) + Math.pow((point.y - pos_base.y), 2)),
                startrad = Math.atan2((point.y - pos_base.y), (point.x - pos_base.x)),
                baserad = this._ourJc.layer(obj.id).getAngle(),
                tmpmask = this._ourJc.rect(0, 0, canvas.width(), canvas.height(), 'rgba(0, 0, 0, 0)')
                .layer("tmp_" + obj.id),
                layer = this._ourJc.layer(obj.id),
                tmpLayer = this._ourJc.layer("tmp_" + obj.id);
            tmpLayer.level('top');
            tmpmask.mousemove((pos) => {
                var nowrad = Math.atan2((pos.y - pos_base.y), (pos.x - pos_base.x)),
                    rad = baserad + (nowrad - startrad);
                layer.rotateTo((rad * 180 / Math.PI), 0, 0);
            });
            tmpmask.mouseup(() => {
                tmpLayer.del();
            });
        };

        //扇形部分は角度変更
        area.mousedown(mdEvent);
        area.mouseover(() => {
            this._ourJc.layer(obj.id).optns.drag.val = false; // ドラッグ無効
        });
        area.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true; // ドラッグ有効
        });
        //文字列部分も角度変更
        text.mousedown(mdEvent);
        text.mouseover(() => {
            this._ourJc.layer(obj.id).optns.drag.val = false; // ドラッグ無効
        });
        text.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true; // ドラッグ有効
        });

        return this;
    }
}

//
//BB_sondeオブジェクト
//
class BB_sonde extends BB_base {
    constructor(_bbObj, _text, _radius1, _radius2, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = '#00FF00';
        }
        this.id = UUID.v1();

        this.type = "sonde";
        this._text = _text;
        this._radius1 = _radius1; //射程範囲
        this._radius2 = _radius2; //偵察範囲
        this._color = _color;
        this._markerx = 0;
        this._markery = 0;
        //描画して登録。初期座標は有効射程分ずらす
        this.draw();
        var px_rad1 = this._bbObj.meter_to_pixel(this._radius1);
        this.move(px_rad1, px_rad1);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }
    draw() {
        var px_rad1 = this._bbObj.meter_to_pixel(this._radius1),
            px_rad2 = this._bbObj.meter_to_pixel(this._radius2),
            obj = this;

        //射程範囲の表示
        this._ourJc.circle(0, 0, px_rad1, this._color, false).opacity(1).layer(this.id);
        var range = this._ourJc.circle(0, 0, px_rad1, this._color, true).opacity(0.2).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.ptsize, '#FFFFFF', true).layer(this.id);
        this._ourJc.text(this._text, 0, -40)
            .align('center').color('#FFFFFF').font('15px sans-serif').layer(this.id);

        //照準円の表示
        var tgtline = this._ourJc.circle(this._markerx, this._markery, px_rad2, this._color, false).opacity(1).layer(this.id),
            tgt = this._ourJc.circle(this._markerx, this._markery, px_rad2, this._color, true).opacity(0.5).layer(this.id),
            cross = this._ourJc.crosshair(this._markerx, this._markery).layer(this.id);
        this._ourJc.layer(this.id).draggable();

        var dragfunc = function(cursor) {
            var followflag = true,
                pos = this.position(),
                base = range.position(),
                layer = obj._ourJc.layer(obj.id),
                dx = cursor.x - base.x,
                dy = cursor.y - base.y;
            if (Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) > px_rad1) {
                //はみだし禁止！
                followflag = false;
            } else {
                followflag = true;
            }

            if (followflag) {
                tgt.translateTo(pos.x, pos.y);
                tgtline.translateTo(pos.x, pos.y);
                cross.translateTo(pos.x, pos.y);
            } else {
                var rad = Math.atan2((cursor.y - base.y), (cursor.x - base.x));
                var x = base.x + px_rad1 * Math.cos(rad);
                var y = base.y + px_rad1 * Math.sin(rad);
                tgt.translateTo(x, y);
                tgtline.translateTo(x, y);
                cross.translateTo(x, y);
            }
            obj._markerx = this._x + this._transformdx;
            obj._markery = this._y + this._transformdy;
        };

        var tgtdrag = function() {
            obj._ourJc.layer(obj.id).optns.drag.val = false;
            this.optns.drag.val = true;
        };

        var tgtundrag = function() {
            obj._ourJc.layer(obj.id).optns.drag.val = true;
            this.optns.drag.val = false;
        };

        var resetfunc = function() {
            // 最初の位置に戻す
            var base = range.position();
            tgt.translateTo(base.x, base.y);
            tgtline.translateTo(base.x, base.y);
            cross.translateTo(base.x, base.y);
            obj._markerx = this._x + this._transformdx;
            obj._markery = this._y + this._transformdy;
            return false;
        };


        //索敵地点の処理
        tgt.draggable(dragfunc);
        cross.draggable(dragfunc);

        //初期状態ではレイヤを優先するため、個別ドラッグを抑止。
        //ターゲット部分でボタンが押下された場合のみターゲットの個別ドラッグを有効化。
        tgt.optns.drag.val = false;
        tgt.mouseover(tgtdrag);
        tgt.mouseout(tgtundrag);
        tgt.dblclick(resetfunc);

        //中心点も同様に処理させる
        //ただし、dblclickはpropagationするのでtgtに任せる
        cross.optns.drag.val = false;
        cross.mouseover(tgtdrag);
        cross.mouseout(tgtundrag);

        return this;
    }

    applyZoom(scale, _x, _y) {
        this._markerx = this._markerx * scale;
        this._markery = this._markery * scale;
        this._bbObj.BB_base.prototype.applyZoom.apply(this, arguments);
        return this;
    }
}

//
//BB_ndsensor オブジェクト
//
class BB_ndsensor extends BB_base {
    constructor(_bbObj, _text, _radius, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 0, 0)';
        }
        this.id = UUID.v1();

        this.type = "ndsensor";
        this._text = _text;
        this._radius = _radius;
        this._color = _color;

        //中央アイコンはファイル依存させないため手打ち。
        this._image = new Image;
        this._image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAIAAAC0tAIdAAAABnRS' + 'TlMA/wAAAP+JwC+QAAAAeElEQVR42q2QbQrAIAiG9WBBO1l0sgUdzFWSE1urwfoh6fvw+oEEBN' + 'sPRxpbER8lKRV5Znkz1YYOwBRCEDnGaFIgT3gqP/K9X5pVvk8ybmmgxU126YLmnJ1zHK2qc3bV' + 'tOlg6XK4eq/2+L+mdfyJltFlnrctlxe8AGPpa/QtEubEAAAAAElFTkSuQmCC';

        //描画して登録。初期座標はx方向に偵察半径+100、y方向に100ずらす
        var obj = this;
        this._image.onload = () => {
            obj.draw();
            var px_rad = this._bbObj.meter_to_pixel(obj._radius);
            obj.move(100 + px_rad, 100);
            obj.regist();
            if (typeof(_callback) === "function") {
                _callback.apply(obj);
            }
            delete this._image;
        };
    }

    draw() {
        var px_rad = this._bbObj.meter_to_pixel(this._radius),
            obj = this,
            above = 10,
            below = 5,
            img_width = this._image.width,
            img_height = this._image.height,
            img_rad = Math.sqrt(Math.pow(this._image.width, 2) + Math.pow(this._image.height, 2)) * 0.5;

        var line = this._ourJc.line({
                points: [
                    [px_rad, 0],
                    [(-1) * px_rad, 0]
                ],
                color: this._color
            })
            .opacity(1).lineStyle({
                lineWidth: 3
            }).layer(this.id),
            pt1col = this._ourJc.circle(px_rad, 0, this._bbObj.ptcolsize, this._color, true).layer(this.id),
            pt1 = this._ourJc.circle(px_rad, 0, this._bbObj.ptsize, "#FFFFFF", true).layer(this.id),
            pt1tra = this._ourJc.circle(px_rad, 0, this._bbObj.pttrasize, "rgba(0,0,0,0)", true).layer(this.id),
            pt2col = this._ourJc.circle((-1) * px_rad, 0, this._bbObj.ptcolsize, this._color, true).layer(this.id),
            pt2 = this._ourJc.circle((-1) * px_rad, 0, this._bbObj.ptsize, "#FFFFFF", true).layer(this.id),
            pt2tra = this._ourJc.circle((-1) * px_rad, 0, this._bbObj.pttrasize, "rgba(0,0,0,0)", true).layer(this.id),
            center = this._ourJc.circle(0, 0, img_rad, this._color, true).layer(this.id),
            centertra = this._ourJc.circle(0, 0, this._bbObj.pttrasize, "rgba(0,0,0,0)", true).layer(this.id);

        this._ourJc.circle(0, 0, img_rad - 2, '#FFFFFF', true).layer(this.id);
        this._ourJc.image(this._image, img_width * (-0.5), img_height * (-0.5), img_width, img_height).layer(this.id);
        this._ourJc.text(this._text, 0, 0 + above + img_height)
            .align('center').color('#FFFFFF').font('15px sans-serif').layer(this.id);
        this._ourJc.layer(this.id).draggable();

        //移動処理(draggableでは回転できないため、独自定義)
        var mdEvent = (point) => {
            var pos_base = center.position(),
                canvas = jc.canvas(this._bbObj.id),
                radius = Math.sqrt(Math.pow((point.x), 2) + Math.pow((point.y), 2)),
                startrad = Math.atan2((point.y - pos_base.y), (point.x - pos_base.x)),
                baserad = this._ourJc.layer(obj.id).getAngle(),
                tmpmask = this._ourJc.rect(0, 0, canvas.width(), canvas.height(), 'rgba(0, 0, 0, 0)')
                .layer("tmp_" + obj.id),
                layer = this._ourJc.layer(obj.id),
                tmpLayer = this._ourJc.layer("tmp_" + obj.id);
            tmpLayer.level('top');
            tmpmask.mousemove((pos) => {
                var nowrad = Math.atan2((pos.y - pos_base.y), (pos.x - pos_base.x)),
                    rad = baserad + (nowrad - startrad);
                layer.rotateTo((rad * 180 / Math.PI), 0, 0);
            });
            tmpmask.mouseup(() => {
                tmpLayer.del();
            });
        };

        //端点は角度変更
        pt1tra.mousedown(mdEvent);
        pt1tra.mouseover(() => {
            this._ourJc.layer(obj.id).optns.drag.val = false; // ドラッグ無効
        });
        pt1tra.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true; // ドラッグ有効
        });
        pt2tra.mousedown(mdEvent);
        pt2tra.mouseover(() => {
            this._ourJc.layer(obj.id).optns.drag.val = false; // ドラッグ無効
        });
        pt2tra.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true; // ドラッグ有効
        });
        return this;
    }
}

//
//BB_vsensorオブジェクト
//
class BB_vsensor extends BB_base {
    constructor(_bbObj, _text, _radiusa, _radiusb, _color, _mode, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(153, 0, 255)';
        }
        if (_mode === undefined) {
            _mode = 'A';
        }
        this.id = UUID.v1();

        this.type = "vsensor";
        this._text = _text;
        this._radiusa = _radiusa;
        this._radiusb = _radiusb;
        this._color = _color;
        this._mode = _mode;

        //描画して登録。初期座標は偵察半径分ずらす
        this.draw();
        var px_rad = _bbObj.meter_to_pixel(this._radiusa);
        this.move(px_rad, px_rad);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }

    draw() {
        var px_rad, modecolor,
            obj = this;

        if (this._mode == 'A') {
            px_rad = this._bbObj.meter_to_pixel(this._radiusa);
            modecolor = '#66FF66';
        } else {
            px_rad = this._bbObj.meter_to_pixel(this._radiusb);
            modecolor = '#00FFFF';
        }

        var area = this._ourJc.circle(0, 0, px_rad, this._color, false).opacity(1).layer(this.id);
        this._ourJc.circle(0, 0, px_rad, this._color, true).opacity(0.5).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.ptsize, this._color, true).layer(this.id).color('#FFFFFF');
        this._ourJc.text(this._text, 0, 20)
            .align('center').layer(this.id).color('#FFFFFF').font('15px sans-serif');

        var moderect = this._ourJc.rect(-7, -25, 14, 17, modecolor, true).layer(this.id);
        var modetext = this._ourJc.text(this._mode, 0, -12)
            .align('center').layer(this.id).color('#000000').font('15px sans-serif');

        var clickfunc = () => {
            obj.modechg.apply(obj);
            return false;
        };

        moderect.click(clickfunc);
        modetext.click(clickfunc);
        area.dblclick(clickfunc);

        this._ourJc.layer(this.id).draggable();
        return this;
    }

    modechg() {
        if (this._mode == 'A') {
            this._mode = 'B';
        } else {
            this._mode = 'A';
        }
        this.redraw();
        return false;
    }
}

//
//BB_howitzerオブジェクト
//
class BB_howitzer extends BB_base {
    constructor(_bbObj, _text, _radius1, _radius2, _radius3, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = '#FFA500';
        }
        this.id = UUID.v1();

        this.type = "howitzer";
        this._text = _text;
        this._radius1 = _radius1; //射程範囲
        this._radius2 = _radius2; //爆風範囲
        this._radius3 = _radius3; //誤差範囲
        this._color = _color;
        this._markerx = 0;
        this._markery = 0;
        //描画して登録。初期座標は有効射程分ずらす
        this.draw();
        var px_rad1 = this._bbObj.meter_to_pixel(this._radius1);
        this.move(px_rad1, px_rad1);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }
    draw() {
        var px_rad1 = this._bbObj.meter_to_pixel(this._radius1),
            px_rad2 = this._bbObj.meter_to_pixel(this._radius2),
            px_rad3 = this._bbObj.meter_to_pixel(this._radius3) + px_rad2,
            obj = this;

        //射程範囲の表示
        this._ourJc.circle(0, 0, px_rad1, this._color, false).opacity(1).layer(this.id);
        var range = this._ourJc.circle(0, 0, px_rad1, this._color, true).opacity(0.2).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.ptsize, '#FFFFFF', true).layer(this.id);
        this._ourJc.text(this._text, 0, -40)
            .align('center').color('#FFFFFF').font('15px sans-serif').layer(this.id);

        //照準円の表示
        var area = this._ourJc.circle(this._markerx, this._markery, px_rad3, this._color, false).opacity(1).layer(this.id),
            tgtline = this._ourJc.circle(this._markerx, this._markery, px_rad2, this._color, false).opacity(1).layer(this.id),
            tgt = this._ourJc.circle(this._markerx, this._markery, px_rad2, this._color, true).opacity(0.3).layer(this.id),
            cross = this._ourJc.crosshair(this._markerx, this._markery).layer(this.id);
        this._ourJc.layer(this.id).draggable();

        var dragfunc = function(cursor) {
            var followflag = true,
                pos = this.position(),
                base = range.position(),
                layer = obj._ourJc.layer(obj.id),
                dx = cursor.x - base.x,
                dy = cursor.y - base.y;
            if (Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) > px_rad1) {
                //はみだし禁止！
                followflag = false;
            } else {
                followflag = true;
            }

            if (followflag) {
                tgt.translateTo(pos.x, pos.y);
                tgtline.translateTo(pos.x, pos.y);
                cross.translateTo(pos.x, pos.y);
                area.translateTo(pos.x, pos.y);
            } else {
                var rad = Math.atan2((cursor.y - base.y), (cursor.x - base.x));
                var x = base.x + px_rad1 * Math.cos(rad);
                var y = base.y + px_rad1 * Math.sin(rad);
                tgt.translateTo(x, y);
                tgtline.translateTo(x, y);
                cross.translateTo(x, y);
                area.translateTo(x, y);
            }
            obj._markerx = area._x + area._transformdx;
            obj._markery = area._y + area._transformdy;
        };

        var tgtdrag = function() {
            obj._ourJc.layer(obj.id).optns.drag.val = false;
            this.optns.drag.val = true;
        };

        var tgtundrag = function() {
            obj._ourJc.layer(obj.id).optns.drag.val = true;
            this.optns.drag.val = false;
        };

        var resetfunc = function() {
            // 最初の位置に戻す
            var base = range.position();
            tgt.translateTo(base.x, base.y);
            tgtline.translateTo(base.x, base.y);
            cross.translateTo(base.x, base.y);
            area.translateTo(base.x, base.y);
            obj._markerx = area._x + area._transformdx;
            obj._markery = area._y + area._transformdy;
            return false;
        };

        //砲撃地点の処理
        tgt.draggable(dragfunc);
        cross.draggable(dragfunc);

        //初期状態ではレイヤを優先するため、個別ドラッグを抑止。
        //ターゲット部分でボタンが押下された場合のみターゲットの個別ドラッグを有効化。
        tgt.optns.drag.val = false;
        tgt.mouseover(tgtdrag);
        tgt.mouseout(tgtundrag);
        tgt.dblclick(resetfunc);

        //マーカーも同様に処理させる
        //ただし、dblclickはpropagationするのでtgtに任せる
        cross.optns.drag.val = false;
        cross.mouseover(tgtdrag);
        cross.mouseout(tgtundrag);

        return this;
    }

    applyZoom(scale, _x, _y) {
        this._markerx = this._markerx * scale;
        this._markery = this._markery * scale;
        this._bbObj.BB_base.prototype.applyZoom.apply(this, arguments);
        return this;
    }
}

//
//BB_bunkerオブジェクト
//
class BB_bunker extends BB_base {
    constructor(_bbObj, _text, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 0, 165)';
        }
        this.id = UUID.v1();

        this.type = "bunker";
        this._text = _text;
        this._rad1 = 28; //攻撃範囲28m
        this._rad2 = 40; //爆風範囲40m
        this._color = _color;
        //描画して登録。初期座標は半径分ずらす
        this.draw();
        var px_rad = this._bbObj.meter_to_pixel(this._rad2);
        this.move(px_rad, px_rad);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }

    draw() {
        var px_rad1 = this._bbObj.meter_to_pixel(this._rad1);
        var px_rad2 = this._bbObj.meter_to_pixel(this._rad2);
        this._ourJc.circle(0, 0, px_rad1, this._color, true).opacity(0.3).layer(this.id);
        this._ourJc.circle(0, 0, px_rad1, this._color, false).opacity(1).layer(this.id);
        this._ourJc.circle(0, 0, px_rad2, this._color, true).opacity(0.2).layer(this.id);
        this._ourJc.circle(0, 0, px_rad2, this._color, false).opacity(1).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.ptsize, this._color, true).layer(this.id).color('#FFFFFF');
        this._ourJc.text(this._text, 0, -10)
            .align('center').layer(this.id).color('#FFFFFF').font('15px sans-serif');
        this._ourJc.layer(this.id).draggable();
        return this;
    }
}

//
//BB_sentryオブジェクト
//
class BB_sentry extends BB_base {
    constructor(_bbObj, _text, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 0, 0)';
        }
        this.id = UUID.v1();

        this.type = "sentry";
        this._text = _text;
        this._radius = 80; //固定値
        this._angle = 120; //固定値
        this._color = _color;
        //描画して登録。初期座標は偵察半径分ずらす
        //マークはファイル依存させないため手打ち。
        this._image = new Image;
        this._image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAIAAAC0tAIdAAAABnR' + 'STlMA/wD/AP83WBt9AAAAYUlEQVR42pWRUQ7AIAhD13txN7gbB2PLWMxUROSrJq8NVJjZVR4M' + 'NAAXYUpHP2h7/nVHt7xk3PkFrAyq6oKIgk1cMLOIZHtv0biTM7ra4NaAOOM1ZPRc4ln2bFv+T' + 'vXKZG6yP1bjQ2hwBAAAAABJRU5ErkJggg==';
        var obj = this;
        this._image.onload = () => {
            obj.draw();
            var px_rad = this._bbObj.meter_to_pixel(obj._radius);
            obj.move(px_rad, px_rad);
            obj.regist();
            if (typeof(_callback) === "function") {
                _callback.apply(obj);
            }
            delete this._image;
        };
    }
    draw() {
        var px_rad = this._bbObj.meter_to_pixel(this._radius),
            obj = this,
            img_width = this._image.width,
            img_height = this._image.height,
            img_rad = Math.sqrt(Math.pow(this._image.width, 2) + Math.pow(this._image.height, 2)) * 0.5;

        this._ourJc.sector(0, 0, px_rad, this._angle, this._color, false).opacity(1).layer(this.id);
        var area = this._ourJc.sector(0, 0, px_rad, this._angle, this._color, true).opacity(0.5).layer(this.id);
        this._ourJc.circle(0, 0, img_rad, this._color, true).opacity(0.9).layer(this.id);
        this._ourJc.circle(0, 0, img_rad - 2, '#ffffff', true).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.pttrasize, 'rgba(0,0,0,0)', true).layer(this.id);
        this._ourJc.image(this._image, img_width * (-0.5), img_height * (-0.5), img_width, img_height).layer(this.id);
        var text = this._ourJc.text(this._text, 50, 0)
            .align('center').layer(this.id).color('#FFFFFF').font('15px sans-serif');
        this._ourJc.layer(this.id).draggable();

        //移動処理(draggableでは回転できないため、独自定義)
        var mdEvent = (point) => {
            var pos_base = area.position(),
                canvas = jc.canvas(this._bbObj.id),
                radius = Math.sqrt(Math.pow((point.x - pos_base.x), 2) + Math.pow((point.y - pos_base.y), 2)),
                startrad = Math.atan2((point.y - pos_base.y), (point.x - pos_base.x)),
                baserad = this._ourJc.layer(obj.id).getAngle(),
                tmpmask = this._ourJc.rect(0, 0, canvas.width(), canvas.height(), 'rgba(0, 0, 0, 0)')
                .layer("tmp_" + obj.id),
                layer = this._ourJc.layer(obj.id),
                tmpLayer = this._ourJc.layer("tmp_" + obj.id);
            tmpLayer.level('top');
            tmpmask.mousemove((pos) => {
                var nowrad = Math.atan2((pos.y - pos_base.y), (pos.x - pos_base.x)),
                    rad = baserad + (nowrad - startrad);
                layer.rotateTo((rad * 180 / Math.PI), 0, 0);
            });
            tmpmask.mouseup(() => {
                tmpLayer.del();
            });
        };

        //扇形部分は角度変更
        area.mousedown(mdEvent);
        area.mouseover(() => {
            this._ourJc.layer(obj.id).optns.drag.val = false; // ドラッグ無効
        });
        area.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true; // ドラッグ有効
        });
        //文字列部分も角度変更
        text.mousedown(mdEvent);
        text.mouseover(() => {
            this._ourJc.layer(obj.id).optns.drag.val = false; // ドラッグ無効
        });
        text.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true; // ドラッグ有効
        });

        return this;
    }
}

//
//BB_aerosentryオブジェクト
//
class BB_aerosentry extends BB_base {
    constructor(_bbObj, _text, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 0, 0)';
        }
        this.id = UUID.v1();

        this.type = "aerosentry";
        this._text = _text;
        this._radius = 40; //固定値
        this._color = _color;
        //描画して登録。初期座標は偵察半径分ずらす
        //マークはファイル依存させないため手打ち。
        this._image = new Image;
        this._image.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA8AAAAPCAIAAAC0tAIdAAAAAXN' + 'SR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAABsSURBVChT' + 'nYxBEoAwDAL7/09HWkgkNid3xnED6IqIdYAU98mEIjtVRnZ62FIKqbOkf9fPocJD3ijxkHzXI' + '1r4GqjsqDu0A2iSKE3+/lvlhBb3ugR4SFoN/JwrvGgUMPqeEk/B7XvkdqoZDSIeqpRXt5iMa4' + 'kAAAAASUVORK5CYII=';
        var obj = this;
        this._image.onload = () => {
            obj.draw();
            var px_rad = this._bbObj.meter_to_pixel(obj._radius);
            obj.move(px_rad, px_rad);
            obj.regist();
            if (typeof(_callback) === "function") {
                _callback.apply(obj);
            }
            delete this._image;
        };
    }

    draw() {
        var px_rad = this._bbObj.meter_to_pixel(this._radius),
            obj = this,
            img_width = this._image.width,
            img_height = this._image.height,
            img_rad = Math.sqrt(Math.pow(this._image.width, 2) + Math.pow(this._image.height, 2)) * 0.5;

        this._ourJc.circle(0, 0, px_rad, this._color, false).opacity(1).layer(this.id);
        var area = this._ourJc.circle(0, 0, px_rad, this._color, true).opacity(0.3).layer(this.id);
        this._ourJc.circle(0, 0, img_rad, this._color, true).opacity(0.9).layer(this.id);
        this._ourJc.circle(0, 0, img_rad - 2, '#ffffff', true).layer(this.id);
        this._ourJc.image(this._image, img_width * (-0.5), img_height * (-0.5), img_width, img_height).layer(this.id);

        this._ourJc.text(this._text, 0, -10)
            .align('center').layer(this.id).color('#FFFFFF').font('15px sans-serif');
        this._ourJc.layer(this.id).draggable();

        return this;
    }
}

//
//BB_bomberオブジェクト
//
class BB_bomber extends BB_base {
    constructor(_bbObj, _text, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 0, 165)';
        }
        this.id = UUID.v1();

        this.type = "bomber";
        this._text = _text;
        this._rad1 = 25; //爆風範囲
        this._rad2 = 0; //着弾誤差範囲
        this._center = [50, 65, 80, 95, 110, 125, 140, 155, 170, 185, 200, 215]; //爆心
        this._color = _color;
        //描画して登録。初期座標は半径分ずらす
        this.draw();
        var px_rad = this._bbObj.meter_to_pixel(this._rad1);
        this.move(px_rad, px_rad);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }
    draw() {
        var i,
            px_rad1 = this._bbObj.meter_to_pixel(this._rad1),
            px_rad2 = px_rad1 + this._bbObj.meter_to_pixel(this._rad2),
            px_len = this._bbObj.meter_to_pixel(this._center[this._center.length - 1]),
            crosshair = [],
            point_ch = [];

        //攻撃位置を変換しておく
        for (i = 0; i < this._center.length; ++i) {
            point_ch[i] = this._bbObj.meter_to_pixel(this._center[i]);
        }

        this._ourJc.scout(0, 0, px_rad1, px_len, this._color, true).opacity(0.2).layer(this.id);
        this._ourJc.scout(0, 0, px_rad1, px_len, this._color, false).opacity(1).layer(this.id);
        var self = this._ourJc.circle(0, 0, this._bbObj.ptsize, '#FFFFFF', true).layer(this.id);

        //攻撃範囲表示
        for (i = 0; i < this._center.length; ++i) {
            this._ourJc.circle(point_ch[i], 0, px_rad1, this._color, false).opacity(1).layer(this.id),
                this._ourJc.circle(point_ch[i], 0, px_rad2, this._color, true).opacity(0.3).layer(this.id);
        }

        //クロスヘア表示
        var angle = (this._ourJc.layer(this.id).getAngle()) * (-180) / Math.PI;
        for (i = 0; i < this._center.length; ++i) {
            crosshair.push(this._ourJc.crosshair(point_ch[i], 0).layer(this.id)
                .rotateTo(angle, point_ch[i], 0));
        }

        this._ourJc.text(this._text, 0, -10)
            .align('center').layer(this.id).color('#FFFFFF').font('15px sans-serif');
        this._ourJc.layer(this.id).draggable();

        //角度変更処理
        var mask = this._ourJc.scout_mask(0, 0, px_rad1, px_len).layer(this.id),
            obj = this;
        mask.mousedown((point) => {
            var canvas = jc.canvas(this._bbObj.id),
                tmpmask = this._ourJc.rect(0, 0, canvas.width(), canvas.height(), 'rgba(0, 0, 0, 0)')
                .layer("tmp_" + obj.id),
                layer = this._ourJc.layer(obj.id),
                tmpLayer = this._ourJc.layer("tmp_" + obj.id);
            tmpLayer.level('top');
            var pos_self = self.position();
            var startrad = Math.atan2((point.y - pos_self.y), (point.x - pos_self.x)),
                baserad = layer.getAngle();
            tmpmask.mousemove((pos) => {
                var nowrad = Math.atan2((pos.y - pos_self.y), (pos.x - pos_self.x));
                var rad = baserad + (nowrad - startrad);
                layer.rotateTo((rad * 180 / Math.PI), 0, 0);
                for (var i = 0; i < crosshair.length; ++i) {
                    crosshair[i].rotateTo((rad * (-180) / Math.PI), point_ch[i], 0);
                }
            });
            tmpmask.mouseup((point) => {
                this._ourJc.layer("tmp_" + obj.id).del();
            });
        });

        mask.mouseover(() => {
            this._ourJc.layer(obj.id).optns.drag.val = false; // ドラッグ無効
        });
        mask.mouseout(() => {
            this._ourJc.layer(obj.id).optns.drag.val = true; // ドラッグ有効
        });

        return this;
    }
}

//
//BB_bascoutオブジェクト
//
class BB_bascout extends BB_base {
    constructor(_bbObj, _text, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 0, 165)';
        }
        this.id = UUID.v1();

        this.type = "bascout";
        this._text = _text;
        this._color = _color;
        this._visible = true;
        //描画して登録。初期座標はとりあえず100づつずらしておく
        this.draw();
        var px_rad = this._bbObj.meter_to_pixel(100);
        this.move(px_rad, px_rad);
        this.regist();
        if (typeof(_callback) === "function") {
            _callback.apply(this);
        }
    }
    draw() {
        var px_wid = this._bbObj.meter_to_pixel(500),
            px_len = this._bbObj.meter_to_pixel(1200),
            px_back = this._bbObj.meter_to_pixel(300),
            obj = this;

        var area = this._ourJc.rect((-1) * px_wid, (-1) * px_back,
                2 * px_wid, px_len, this._color, true)
            .opacity(0.2).layer(this.id).visible(this._visible),
            areaf = this._ourJc.rect((-1) * px_wid, (-1) * px_back,
                2 * px_wid, px_len, this._color, false)
            .opacity(1).layer(this.id).visible(this._visible),
            bar = this._ourJc.line([
                [0, 7],
                [0, 25]
            ], this._color)
            .lineStyle({
                lineWidth: 2
            }).layer(this.id),
            arrow = this._ourJc.line([
                [5, 15],
                [0, 25],
                [-5, 15]
            ], this._color, true).layer(this.id),
            // center  = this._ourJc.circle(0, 0, this._bbObj.ptcolsize, this._color, true).layer(this.id),
            centerf = this._ourJc.circle(0, 0, this._bbObj.ptsize, '#FFFFFF', true).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.pttrasize, 'rgba(0,0,0,0)', true).layer(this.id);

        this._ourJc.text(this._text, 0, -10)
            .align('center').color('#FFFFFF').font('15px sans-serif').layer(this.id);
        this._ourJc.layer(this.id).draggable();

        //角度変更処理
        var mdEvent = (point) => {
            //if (this._ourJc.layer(obj.id).optns.drag.val==true){return false;}
            var canvas = jc.canvas(this._bbObj.id),
                tmpmask = this._ourJc.rect(0, 0, canvas.width(), canvas.height(), 'rgba(0, 0, 0, 0)')
                .layer("tmp_" + obj.id),
                layer = this._ourJc.layer(obj.id),
                tmpLayer = this._ourJc.layer("tmp_" + obj.id);
            tmpLayer.level('top');
            var pos_self = centerf.position();
            var startrad = Math.atan2((point.y - pos_self.y), (point.x - pos_self.x)),
                baserad = layer.getAngle();
            tmpmask.mousemove((pos) => {
                var nowrad = Math.atan2((pos.y - pos_self.y), (pos.x - pos_self.x));
                var rad = baserad + (nowrad - startrad);
                layer.rotateTo((rad * 180 / Math.PI), 0, 0);
            });
            tmpmask.mouseup((point) => {
                tmpLayer.del();
            });
            return true;
        };
        areaf.mousedown(mdEvent);
        bar.mousedown(mdEvent);
        arrow.mousedown(mdEvent);

        //  ドラッグ無効
        var drugoff = () => {
            this._ourJc.layer(obj.id).optns.drag.val = false;
        };
        areaf.mouseover(drugoff);
        arrow.mouseover(drugoff);
        bar.mouseover(drugoff);

        //  ドラッグ有効
        var drugon = () => {
            this._ourJc.layer(obj.id).optns.drag.val = true;
        };
        areaf.mouseout(drugon);
        arrow.mouseout(drugon);
        bar.mouseout(drugon);

        centerf.dblclick(() => {
            obj._visible = !(obj._visible);
            area.visible(obj._visible);
            areaf.visible(obj._visible);
        });

        return this;
    }
}

class BB_icon extends BB_base {
    constructor(_bbObj, _text, _file, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(0, 255, 255)';
        }
        this.id = UUID.v1();

        if ((_file = sanitize_filepath(_file)) == null) {
            return null;
        }

        this.type = "icon";
        this._text = _text;
        this._file = _file;
        this._color = _color;

        //描画して登録。初期座標は半径分ずらす
        this._image = new Image;
        this._image.src = _file + '?' + salt;
        var obj = this;
        this._image.onload = () => {
            var px_dia = Math.sqrt(Math.pow(obj._image.width, 2) + Math.pow(obj._image.height, 2));
            obj.draw();
            obj.move(px_dia, px_dia);
            obj.regist();
            if (typeof(_callback) === "function") {
                _callback.apply(obj);
            }
            delete this._image;
        };
    }
    draw() {
        var img_width = this._image.width,
            img_height = this._image.height,
            px_rad = Math.sqrt(Math.pow(this._image.width, 2) + Math.pow(this._image.height, 2)) * 0.5;
        this._ourJc.circle(0, 0, px_rad, this._color, true).opacity(0.9).layer(this.id);
        this._ourJc.circle(0, 0, px_rad - 2, '#FFFFFF', true).layer(this.id);
        this._ourJc.circle(0, 0, this._bbObj.pttrasize, 'rgba(0,0,0,0)', true).layer(this.id);
        this._ourJc.image(this._image, img_width * (-0.5), img_height * (-0.5), img_width, img_height).layer(this.id);
        this._ourJc.text(this._text, img_width * 0.5 + 5, 0)
            .layer(this.id).color('#FFFFFF').font('15px sans-serif')
            .align('left').baseline('middle');
        this._ourJc.layer(this.id).draggable();

        return this;
    }
}

//
//BB_waftオブジェクト
//
class BB_waft extends BB_base {
    constructor(_bbObj, _text, _file, _color, _callback) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(0, 255, 255)';
        }
        this.id = UUID.v1();

        if ((_file = sanitize_filepath(_file)) == null) {
            return null;
        }

        this.type = "waft";
        this._text = _text;
        this._file = _file;
        this._rad = 20; //大ざっぱに全長40m程度?
        this._color = _color;

        //描画して登録。初期座標は半径分ずらす
        this._image = new Image;
        this._image.src = _file + '?' + salt;
        var obj = this,
            px_rad = this._bbObj.meter_to_pixel(this._rad);
        this._image.onload = () => {
            obj.draw();
            obj.move(px_rad, px_rad);
            obj.regist();
            if (typeof(_callback) === "function") {
                _callback.apply(obj);
            }
            delete this._image;
        };
    }
    draw() {
        var px_rad = this._bbObj.meter_to_pixel(this._rad),
            img_width = this._image.width,
            img_height = this._image.height,
            img_rate = px_rad * 2 / ((img_width >= img_height) ? img_width : img_height);

        img_width = img_width * img_rate;
        img_height = img_height * img_rate;

        var handle = this._ourJc.circle(0, 0, px_rad + (10 * this._bbObj.zoomScale), this._color, true).opacity(0.3).layer(this.id);
        this._ourJc.circle(0, 0, px_rad, this._color, true).opacity(1).layer(this.id);
        this._ourJc.image(this._image, img_width * (-0.5), img_height * (-0.5), img_width, img_height).layer(this.id);
        this._ourJc.text(this._text, 0, -25)
            .align('center').layer(this.id).color('#FFFFFF').font('15px sans-serif');

        this._ourJc.layer(this.id).draggable();

        //角度変更処理
        var obj = this,
            layer = jc.layer(this.id),
            canvas = jc.canvas(this._bbObj.id);

        handle.mousedown((point) => {
            var pos_hdl = handle.position();
            // マウスイベントフック用の四角形を最前面に展開
            var tmpmask = this._ourJc.rect(0, 0, canvas.width(), canvas.height(), 'rgba(0, 0, 0, 0)')
                .layer("tmp_" + obj.id);
            jc.layer("tmp_" + obj.id).level('top');

            var startrad = Math.atan2((point.y - pos_hdl.y), (point.x - pos_hdl.x)),
                baserad = layer.getAngle();
            tmpmask.mousemove((pos) => {
                var nowrad = Math.atan2((pos.y - pos_hdl.y), (pos.x - pos_hdl.x));
                var rad = baserad + (nowrad - startrad);
                layer.rotateTo((rad * 180 / Math.PI), 0, 0);
            });
            tmpmask.mouseup((point) => {
                this._ourJc.layer("tmp_" + obj.id).del();
            });
        });

        handle.mouseover(() => {
            layer.optns.drag.val = false; // ドラッグ無効
        });
        handle.mouseout(() => {
            layer.optns.drag.val = true; // ドラッグ有効
        });

        return this;
    }
}
//
//BB_freehandオブジェクト
//
class BB_freehand extends BB_base {
    constructor(_bbObj, _text, _color) {
        super(_bbObj);
        if (_color === undefined) {
            _color = 'rgb(255, 255, 255)';
        }
        this.id = UUID.v1();
        this.type = "freehand";
        this._text = _text;
        this._color = _color;
        this._step = 0;
        this._stepcol = new Array;
        this._undoCache = new Array;
        this._hooker = undefined;

        //layerを確保するためのダミー画像を設置するのみ
        this._ourJc.rect(0, 0, 1, 1, 'rgba(0, 0, 0, 0)').layer(this.id);
        this.regist();
    }
    color(_color) {
        if (_color === undefined) {
            return this._color;
        }
        this._color = _color;
        return this;
    }

    //BB_baseからプロトタイプをコピー
    //this.BB_freehand.prototype.toString = this.BB_base.prototype.toString;
    //this.BB_freehand.prototype.regist   = this.BB_base.prototype.regist;
    //this.BB_freehand.prototype.up       = this.BB_base.prototype.up;
    //this.BB_freehand.prototype.down     = this.BB_base.prototype.down;
    //this.BB_freehand.prototype.del      = this.BB_base.prototype.del;
    //this.BB_freehand.prototype.move     = this.BB_base.prototype.move;
    //this.BB_freehand.prototype.moveTo   = this.BB_base.prototype.moveTo;

    redraw() {
        for (var i = 1; i <= this._step; i++) {
            var points = jc("#" + i, {
                canvas: this._bbObj.id,
                layer: this.id
            }).points();
            jc("#" + i, {
                canvas: this._bbObj.id,
                layer: this.id
            }).del();
            this._ourJc.line(points, this._stepcol[i])
                .layer(this.id).id(i).lineStyle({
                    lineWidth: 3
                });
        }
    }

    applyZoom(scale, _x, _y) {
        var posx = jc.layer(this.id)._transformdx,
            posy = jc.layer(this.id)._transformdy;
        jc.layer(this.id).translate(posx * scale - posx - _x * scale, posy * scale - posy - _y * scale);

        for (var i = 1; i <= this._step; i++) {
            var points = jc("#" + i, {
                canvas: this._bbObj.id,
                layer: this.id
            }).points();
            for (var j = 0; j < points.length; j++) {
                points[j] = [(points[j])[0] * scale, (points[j])[1] * scale];
            }
            jc("#" + i, {
                canvas: this._bbObj.id,
                layer: this.id
            }).del();
            this._ourJc.line(points, this._stepcol[i])
                .layer(this.id).id(i).lineStyle({
                    lineWidth: 3
                });
        }
    }

    start() {
        var obj = this,
            // layer  = this._ourJc.layer(this.id),
            canvas = jc.canvas(this._bbObj.id);

        if (this._hooker !== undefined) return this;

        // 描画開始時にundoキャッシュをクリア
        this._undoCache.length = 0;

        // マウスイベントフック用の四角形を最前面に展開
        this._hooker = UUID.v1();
        var hooker = this._ourJc.rect(0, 0, canvas.width(), canvas.height(), 'rgba(0, 0, 0, 0)')
            .layer(this._hooker).level('top');

        hooker.click(() => {
            return false;
        });
        hooker.dblclick(() => {
            return false;
        });
        hooker.mousemove(() => {
            return false;
        });
        hooker.mousedown((ptstart) => {
            //追記したのでundoキャッシュをクリアする
            obj._undoCache.length = 0;

            obj._step++;
            obj._stepcol[obj._step] = obj._color;
            var line = this._ourJc.line([
                    [ptstart.x, ptstart.y],
                    [ptstart.x, ptstart.y]
                ], obj._color)
                .layer(obj.id).id(obj._step).lineStyle({
                    lineWidth: 3
                });
            hooker.mousemove((point) => {
                line.addPoint(point.x, point.y);
                return false;
            });
            return false;
        });

        hooker.mouseup(() => {
            hooker.mousemove(() => {});
            return false;
        });

        return this;
    }

    undo() {
        // 描画処理中でなければそのまま抜ける
        if (this._hooker === undefined) return this;

        if (this._step != 0) {
            this._undoCache.push({
                color: this._stepcol[this._step],
                points: jc("#" + this._step, {
                    canvas: this._bbObj.id,
                    layer: this.id
                }).points()
            });
            this._stepcol.splice(this._step, 1);
            jc("#" + this._step, {
                canvas: this._bbObj.id,
                layer: this.id
            }).del();
            this._step--;
        }
        return this;
    }

    redo() {
        // 描画処理中でなければそのまま抜ける
        if (this._hooker === undefined) return this;

        // undoキャッシュにデータがなければそのまま抜ける
        if (this._undoCache.length == 0) return this;

        var cache = this._undoCache.pop();
        this._step++;
        this._stepcol[this._step] = cache.color;
        this._ourJc.line(cache.points, cache.color)
            .layer(this.id).id(this._step).lineStyle({
                lineWidth: 3
            });

        return this;
    }

    end() {
        // イベントフック用の四角形を消す
        (jc.layer(this._hooker)).del();
        this._hooker = undefined;

        // undoキャッシュをクリア
        this._undoCache.length = 0;

        return this;
    }
}

